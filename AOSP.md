# 1. Android平台架构

## Q1：android架构

![image-20210505121208615](.\images\image-20210505121208615.png)

## Q2：Linux内核

Android平台的基础是Linux内核。例如Android Runtime（ART）依赖Linux内核来执行底层功能，例如线程和底层内存管理。

利用Linux内核可让Android利用主要安全功能，并且允许设备制造商为内核开发硬件驱动程序。

注意到android的binder是在Linux内核层的

## Q3：硬件抽象层（HAL）

HAL层，Hardware Abstraction Layer，是在具体的硬件平台上抽象出来的一个硬件接口层，北向向上层软件提供统一的接口，以实现上层软件与底层硬件的隔离。内部对南向的硬件的功能进行封装。

HAL层使得系统在新硬件上的移植变得异常简单，只需提供新硬件的抽象层即可。

## Q4：Android Runtime

Android的运行环境，从android5.0（api21）之后，从dalvik虚拟机切换至ART虚拟机。

ART虚拟机的特点：

1. AOT和JIT编译结合
2. 优化的垃圾回收（GC）
3. Android 9（api28）及更高版本的系统中，支持将应用软件包中的dex格式文件转换为更紧凑的机器代码

Android还包含一套核心运行时库，可提供Java API框架所使用的Java编程语言中的大部分功能，包括一些Java 8功能

## Q5：native C/C++ 库

许多核心Android系统组价和服务（例如ART和HAL）构建自原生代码，需要以C/C++编写的原生库。

例如开源的web浏览器引擎webkit，知名的libc库等。

## Q6：Java API 框架层

通过java语言实现，面向系统应用和普通应用提供开发接口。接口包括：

1. View系统
2. Resource系统
3. Notification系统
4. Activity Manager
5. Content Provider

## Q7：应用层

包括系统应用和其他普通应用，通过API框架层开发应用，无需关注底层实现。

# 2. AOSP环境配置

首先参考Linux.md中关于Linux安装与远程配置的步骤，完成配置。

## Q1：什么是repo？

repo是谷歌为有效管理安卓代码而开发的使用python语言、基于git命令和manifest-xml文件对多个git仓进行批量下载、提交等操作的工具工程。repo本身包含可执行入口脚本repo和工程脚本git仓，通过以repo开头的repo init、repo sync、repo upload等不同命令实现不同操作。

repo依赖的python版本是2.x，推荐2.7

# 3. Binder

## Q1：什么是Binder？

A：Binder是android中主要的IPC方式，通过mmap实现一次拷贝，比Socket、管道传输速度更快，比共享内存更安全可控。

## Q2：介绍下Linux的mmap函数的原理？它为何可用于实现Binder的一次拷贝？

相关linux概念：虚拟地址空间，物理内存等，详细参考【操作系统】

介绍mmap之前，需要了解很多概念

【概念1：页缓存】

**Linux进行I/O操作，将磁盘中的内容读取到Page Cache（页缓存），该层位于用户与磁盘之间，提升了对磁盘的访问性能**

**但是Page Cache是运行在内核空间的，用户空间不能直接寻址，所以当用户进程需使用该数据时，需将该数据从Page Cache拷贝到用户进程的堆内存**

【概念2：虚拟内存/虚拟地址空间】

**虚拟内存和虚拟地址空间是一个概念，下面统一用*虚拟地址空间***

**虚拟地址空间技术为每个进程提供了一个非常大的、一致的、私有的地址空间**

**它使得应用程序认为它拥有连续可用的内存（一个完整可用的地址空间），而实际上，它通常是被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘储存器上，在需要时进行数据交换**

**对于32位系统，每个进程在创建加载的时候，都会被分配一个大小为4G（2^32）的连续的虚拟地址空间。虚拟的意思是，这个地址空间是不存在的，仅仅是每个进程“认为”自己拥有4G的内存，而实际上，它用了多少空间，操作系统就在磁盘上划出多少空间给它。**

**4G的虚拟地址空间，1G分配给内核空间，3G分配给用户空间**

**在进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发*缺页异常*，进行数据拷贝**

【概念3：MMU】

**MMU（Memory Management Unit），内存管理单元，是一种负责处理CPU的内存访问请求的计算机硬件**

**负责虚拟地址与物理地址的转换，提供硬件机制的内存访问授权**

【概念4：从二次拷贝理解虚拟内存和物理内存】

**以将磁盘内容读取到用户空间为例，用户空间发起read()的系统调用，第一步将磁盘内容读取到内核空间的Page Cache，由于用户空间是无法直接寻址内核空间的，所以还需要第二步，将Page Cache的内容拷贝到用户空间。**

**整个操作过程，无论是用户态的操作，还是内核态的操作，MMU都屏蔽了具体的物理内存。**

**换句话说，第一步拷贝，把磁盘内容读取到内核态的虚拟地址空间（实际上，是读取到物理内存中，但MMU对CPU屏蔽了这些）。**

**第二步拷贝，把内核态的虚拟地址空间的内容，读取到用户态的虚拟地址空间（实际上，从物理内存的视角，是将内核态虚拟地址对应的物理内存中的内容，拷贝到用户态虚拟地址对应的物理内容中），但对于CPU来讲，这些操作是感知不到物理内存的**

**从上面的总结可以引出mmap，两次拷贝的模型中，用户态和内核态的虚拟地址空间，分别映射到不同的物理地址。假如可以让二者映射到同一块物理地址，是否就可以避免二次拷贝，使二者去同一块物理内存寻址呢？**



下面正式介绍mmap

**mmap是Linux提供的一种内存映射的方法，它将一个文件（或物理内存）映射到进程的地址空间中（既可以映射到用户地址空间，也可以映射到内核地址空间），实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的对应关系**

**mmap可以用于Binder，通过将Server进程的用户空间和内核空间的某一段虚拟地址映射到同一块物理内存，实现IPC通信的一次拷贝**

## Q3：谈一谈Binder实现一次拷贝的流程？

**mmap是Linux提供的一种内存映射的方法，它将一个文件（或物理内存）映射到进程的地址空间中（既可以映射到用户地址空间，也可以映射到内核地址空间），实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的对应关系**

**mmap可以用于Binder，通过将Server进程的用户空间和内核空间的某一段虚拟地址映射到同一块物理内存，实现IPC通信的一次拷贝**

**其实现一次拷贝的流程如下：**



## Q4：介绍下一次完整的Binder IPC通信的过程？

