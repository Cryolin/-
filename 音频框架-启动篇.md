# 1 audioserver进程启动

启动配置文件：audioserver.rc：

```
frameworks/av/media/audioserver/audioserver.rc

service audioserver /system/bin/audioserver
    class core
    user audioserver
    # media gid needed for /dev/fm (radio) and for /data/misc/media (tee)
    group audio camera drmrpc media mediadrm net_bt net_bt_admin net_bw_acct wakelock
    capabilities BLOCK_SUSPEND
    ioprio rt 4
    task_profiles ProcessCapacityHigh HighPerformance
    onrestart restart vendor.audio-hal
    onrestart restart vendor.audio-hal-4-0-msd
    # Keep the original service names for backward compatibility
    onrestart restart vendor.audio-hal-2-0
    onrestart restart audio-hal-2-0
```

启动入口位于main_audioserver.cpp

```C++
frameworks/av/media/audioserver/main_audioserver.cpp

int main(int argc __unused, char **argv)
{
    // TODO: update with refined parameters
    limitProcessMemory(
        "audio.maxmem", /* "ro.audio.maxmem", property that defines limit */
        (size_t)512 * (1 << 20), /* SIZE_MAX, upper limit in bytes */
        20 /* upper limit as percentage of physical RAM */);

    signal(SIGPIPE, SIG_IGN);

#if 1
    // FIXME See bug 165702394 and bug 168511485
    const bool doLog = false;
#else
    bool doLog = (bool) property_get_bool("ro.test_harness", 0);
#endif

    pid_t childPid;
    if (doLog && (childPid = fork()) != 0) {
        // 因为doLog是false，这部分代码省略
        ......        
    } else {
        // all other services
        if (doLog) {
        // 因为doLog是false，这部分代码省略
        ......    
        }
        
        // 核心代码start
        android::hardware::configureRpcThreadpool(4, false /*callerWillJoin*/);
        sp<ProcessState> proc(ProcessState::self());
        sp<IServiceManager> sm = defaultServiceManager();
        ALOGI("ServiceManager: %p", sm.get());
        AudioFlinger::instantiate();
        AudioPolicyService::instantiate();

        // AAudioService should only be used in OC-MR1 and later.
        // And only enable the AAudioService if the system MMAP policy explicitly allows it.
        // This prevents a client from misusing AAudioService when it is not supported.
        aaudio_policy_t mmapPolicy = property_get_int32(AAUDIO_PROP_MMAP_POLICY,
                                                        AAUDIO_POLICY_NEVER);
        if (mmapPolicy == AAUDIO_POLICY_AUTO || mmapPolicy == AAUDIO_POLICY_ALWAYS) {
            AAudioService::instantiate();
        }

        ProcessState::self()->startThreadPool();
        IPCThreadState::self()->joinThreadPool();
        // 核心代码end
    }
}
```

抽取核心代码：

```C++
frameworks/av/media/audioserver/main_audioserver.cpp

int main(int argc __unused, char **argv)
{   
    // 一、获得一个ProcessState的实例
    sp<ProcessState> proc(ProcessState::self());
    // 二、audioServer进程作为ServiceManager的客户端，需要向ServiceManager注册服务
    // 调用defaultServiceManager()得到一个IserviceManager
    sp<IServiceManager> sm = defaultServiceManager();
    // 三、初始化音频系统的AudioFlinger服务
    AudioFlinger::instantiate();
    // 四、初始化音频系统的AudioPolicyService服务
    AudioPolicyService::instantiate();

    // 五、按需初始化音频系统的AAudioService服务
    aaudio_policy_t mmapPolicy = property_get_int32(AAUDIO_PROP_MMAP_POLICY,
    AAUDIO_POLICY_NEVER);
    if (mmapPolicy == AAUDIO_POLICY_AUTO || mmapPolicy == AAUDIO_POLICY_ALWAYS) {
    AAudioService::instantiate();
    }

    // 六、创建一个线程池
    ProcessState::self()->startThreadPool();
    // 将自己加入该线程池
    IPCThreadState::self()->joinThreadPool();
    }
}
```

上面的核心步骤会分别展开说明

## 1.1 ProcessState::self

主要针对这行代码展开说明：

```C++
// main_audioserver.cpp
	// 一、获得一个ProcessState的实例
    sp<ProcessState> proc(ProcessState::self());
```

```C++
// ProcessState.cpp

sp<ProcessState> ProcessState::self()
{
    return init(kDefaultDriver, false);
}

// 通过std::once_flag和std::call_once实现单例，即sp<ProcessState>::make(driver)只调用一次
// 相应的，gProcess也只初始化一次
sp<ProcessState> ProcessState::init(const char *driver, bool requireDefault)
{
    [[clang::no_destroy]] static sp<ProcessState> gProcess;
    [[clang::no_destroy]] static std::mutex gProcessMutex;

    if (driver == nullptr) {
        std::lock_guard<std::mutex> l(gProcessMutex);
        return gProcess;
    }

    [[clang::no_destroy]] static std::once_flag gProcessOnce;
    std::call_once(gProcessOnce, [&](){
        if (access(driver, R_OK) == -1) {
            ALOGE("Binder driver %s is unavailable. Using /dev/binder instead.", driver);
            driver = "/dev/binder";
        }

        std::lock_guard<std::mutex> l(gProcessMutex);
        gProcess = sp<ProcessState>::make(driver);
    });

    return gProcess;
}
```

sp<ProcessState>智能指针的make函数，实际上是执行了ProcessState的构造函数，然后返回智能指针

```C++
// StrongPointer.h
template <typename T>
template <typename... Args>
sp<T> sp<T>::make(Args&&... args) {
    T* t = new T(std::forward<Args>(args)...);
    sp<T> result;
    result.m_ptr = t;
    t->incStrong(t);  // bypass check_not_on_stack for heap allocation
    return result;
}
```

查看ProcessState的构造函数

```C++
// ProcessState.cpp

ProcessState::ProcessState(const char *driver)
    : mDriverName(String8(driver))
        // 打开/dev/binder这个设备，这是android在内核中专门用于完成进程间通信而设置的一个虚拟设备。
    , mDriverFD(open_driver(driver))
    , mVMStart(MAP_FAILED)
    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)
    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)
    , mExecutingThreadsCount(0)
    , mWaitingForThreads(0)
    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)
    , mStarvationStartTimeMs(0)
    , mThreadPoolStarted(false)
    , mThreadPoolSeq(1)
    , mCallRestriction(CallRestriction::NONE)
{

    if (mDriverFD >= 0) {
        // mmap the binder, providing a chunk of virtual address space to receive transactions.
        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        if (mVMStart == MAP_FAILED) {
            // *sigh*
            ALOGE("Using %s failed: unable to mmap transaction memory.\n", mDriverName.c_str());
            close(mDriverFD);
            mDriverFD = -1;
            mDriverName.clear();
        }
    }
}
```

总结，ProcessState::self做了三件事：

- 打开/dev/binder设备，这就相当于与内核的Binder驱动有了交互的通道。
- 对返回的fd使用mmap，这样Binder驱动就会分配一块内存来接收数据。
- 由于ProcessState的惟一性，因此一个进程只打开设备一次。

## 1.2 defaultServiceManager

主要针对这行代码展开说明：

```C++
// 二、audioServer进程作为ServiceManager的客户端，需要向ServiceManager注册服务
    // 调用defaultServiceManager()得到一个IserviceManager
    sp<IServiceManager> sm = defaultServiceManager();
```

defaultServiceManager()函数位于IServiceManager.cpp：

```C++
// IServiceManager.cpp

using AidlServiceManager = android::os::IServiceManager;

[[clang::no_destroy]] static std::once_flag gSmOnce;
[[clang::no_destroy]] static sp<IServiceManager> gDefaultServiceManager;

sp<IServiceManager> defaultServiceManager()
{
    // 可以看到也是个单例
    std::call_once(gSmOnce, []() {
        sp<AidlServiceManager> sm = nullptr;
        while (sm == nullptr) {
            sm = interface_cast<AidlServiceManager>(ProcessState::self()->getContextObject(nullptr));
            if (sm == nullptr) {
                ALOGE("Waiting 1s on context object on %s.", ProcessState::self()->getDriverName().c_str());
                sleep(1);
            }
        }

        gDefaultServiceManager = sp<ServiceManagerShim>::make(sm);
    });

    return gDefaultServiceManager;
}
```

//  TODO

https://www.kancloud.cn/alex_wsc/android_depp/412925

## 1.3 AudioFlinger::instantiate

AudioFlinger服务创建，详见第二章

## 1.4 AudioPolicyService::instantiate

AudioPolicyService服务创建，详见第三章

## 1.5 AAudioService::instantiate

AAudioService服务创建，详见第四章

## 1.6 start&joinThreadPool

# 2 AudioFlinger服务

AudioFlinger是audioserver进程中的一个实名service，其名称为："media.audio_flinger":

```c++
class AudioFlinger :
    public BinderService<AudioFlinger>,
    public BnAudioFlinger
{
public:
	static const char* getServiceName() ANDROID_API { return "media.audio_flinger"; }
}
```

audioservice进程启动时，会调用AudioFlinger::instantiate()，该函数会创建一个AudioFlinger对象，然后将该Service添加到ServiceManager。

下面重点看下AudioFlinger构造函数：

```c++
AudioFlinger::AudioFlinger()
    : BnAudioFlinger(),
	 // 初始化列表，一些成员初始化
      mMediaLogNotifier(new AudioFlinger::MediaLogNotifier()),
      mPrimaryHardwareDev(NULL),
      mAudioHwDevs(NULL),
      mHardwareStatus(AUDIO_HW_IDLE),
      mMasterVolume(1.0f),
      mMasterMute(false),
      // mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX),
      mMode(AUDIO_MODE_INVALID),
      mBtNrecIsOff(false),
      mIsLowRamDevice(true),
      mIsDeviceTypeKnown(false),
      mTotalMemory(0),
      mClientSharedHeapSize(kMinimumClientSharedHeapSizeBytes),
      mGlobalEffectEnableTime(0),
      mPatchPanel(this),
      mDeviceEffectManager(this),
      mSystemReady(false)
{
    // unsigned instead of audio_unique_id_use_t, because ++ operator is unavailable for enum
    for (unsigned use = AUDIO_UNIQUE_ID_USE_UNSPECIFIED; use < AUDIO_UNIQUE_ID_USE_MAX; use++) {
        // zero ID has a special meaning, so unavailable
        mNextUniqueIds[use] = AUDIO_UNIQUE_ID_USE_MAX;
    }

    const bool doLog = property_get_bool("ro.test_harness", false);
    if (doLog) {
        mLogMemoryDealer = new MemoryDealer(kLogMemorySize, "LogWriters",
                MemoryHeapBase::READ_ONLY);
        (void) pthread_once(&sMediaLogOnce, sMediaLogInit);
    }

    // reset battery stats.
    // if the audio service has crashed, battery stats could be left
    // in bad state, reset the state upon service start.
    // 重置电池状态
    // 如果audioserver crash，电池可能处于不良状态，需要在audioserver重启时重置电池状态
    BatteryNotifier::getInstance().noteResetAudio();

    //创建设备HAL层接口，用于hidl绑定
    mDevicesFactoryHal = DevicesFactoryHalInterface::create();
          
    //创建音效HAL层接口，用于hidl绑定
    mEffectsFactoryHal = EffectsFactoryHalInterface::create();

    mMediaLogNotifier->run("MediaLogNotifier");
    std::vector<pid_t> halPids;
    mDevicesFactoryHal->getHalPids(&halPids);
    TimeCheck::setAudioHalPids(halPids);

    // Notify that we have started (also called when audioserver service restarts)
    mediametrics::LogItem(mMetricsId)
        .set(AMEDIAMETRICS_PROP_EVENT, AMEDIAMETRICS_PROP_EVENT_VALUE_CTOR)
        .record();
}
```

没有特别要说明的，在AudioFlinger对象创建完成后，会被添加到ServiceManager中，ServiceManager会持有sp<AudioFlinger>，相应的，AudioFlinger::onFirstRef()会被调用：

```c++
void AudioFlinger::onFirstRef()
{
    Mutex::Autolock _l(mLock);

    /* TODO: move all this work into an Init() function */
    char val_str[PROPERTY_VALUE_MAX] = { 0 };
    if (property_get("ro.audio.flinger_standbytime_ms", val_str, NULL) >= 0) {
        uint32_t int_val;
        if (1 == sscanf(val_str, "%u", &int_val)) {
            mStandbyTimeInNsecs = milliseconds(int_val);
            ALOGI("Using %u mSec as standby time.", int_val);
        } else {
            mStandbyTimeInNsecs = kDefaultStandbyTimeInNsecs;
            ALOGI("Using default %u mSec as standby time.",
                    (uint32_t)(mStandbyTimeInNsecs / 1000000));
        }
    }

    mMode = AUDIO_MODE_NORMAL;

    gAudioFlinger = this;

    mDevicesFactoryHalCallback = new DevicesFactoryHalCallbackImpl;
    mDevicesFactoryHal->setCallbackOnce(mDevicesFactoryHalCallback);
}
```

除了设置mMode为AUDIO_MODE_NORMAL外，感觉也没什么特别的。

# 3 AudioPolicyService服务

AudioPolicyService是音频策略的制定者，与AudioFlinger的启动一样，也是先看构造函数，然后看onFirstRef()

AudioPolicyService简单的类图关系：

![image-20211029223135545](.\images\image-20211029223135545.png)

## 3.1 构造函数

```c++
AudioPolicyService::AudioPolicyService()
    : BnAudioPolicyService(),
      mAudioPolicyManager(NULL),
      mAudioPolicyClient(NULL),
      mPhoneState(AUDIO_MODE_INVALID),
      mCaptureStateNotifier(false) {
}
```

主要是一些成员的初始化

## 3.2 onFirstRef()

```c++
void AudioPolicyService::onFirstRef()
{
    {
        Mutex::Autolock _l(mLock);

        // start audio commands thread
        mAudioCommandThread = new AudioCommandThread(String8("ApmAudio"), this);
        // start output activity command thread
        mOutputCommandThread = new AudioCommandThread(String8("ApmOutput"), this);

        // 关注下面两行代码即可
        mAudioPolicyClient = new AudioPolicyClient(this);
        mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);
    }
    // load audio processing modules
    sp<AudioPolicyEffects> audioPolicyEffects = new AudioPolicyEffects();
    sp<UidPolicy> uidPolicy = new UidPolicy(this);
    sp<SensorPrivacyPolicy> sensorPrivacyPolicy = new SensorPrivacyPolicy(this);
    {
        Mutex::Autolock _l(mLock);
        mAudioPolicyEffects = audioPolicyEffects;
        mUidPolicy = uidPolicy;
        mSensorPrivacyPolicy = sensorPrivacyPolicy;
    }
    uidPolicy->registerSelf();
    sensorPrivacyPolicy->registerSelf();
}
```

看createAudioPolicyManager()

```c++
extern "C" AudioPolicyInterface* createAudioPolicyManager(
        AudioPolicyClientInterface *clientInterface)
{
    // 关键步骤1：创建AudioPolicyManager
    AudioPolicyManager *apm = new AudioPolicyManager(clientInterface);

    // 关键步骤2：apm->initialize()
    status_t status = apm->initialize();
    if (status != NO_ERROR) {
        delete apm;
        apm = nullptr;
    }
    return apm;
}
```

下面以两个关键步骤分别展开：

### 3.2.1 new AudioPolicyManager()



### 3.2.2 apm->initialize()

