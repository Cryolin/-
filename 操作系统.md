# 1. 概述&特征

## Q1：操作系统定义

操作系统：是控制和管理计算机系统内各种硬件和软件资源、有效地组织多道程序运行的系统软件（或程序集合），是用户与计算机之间的接口。

## Q2：操作系统特征？

并发，共享，虚拟，异步

## Q3：什么是并发，并发与并行的区别是什么？

并发指两个或多个事件在同一时间间隔内发生。这些事情宏观上是同时发生的，微观上是交替发生的。

并行指两个或多个事件在同一时刻发生。

操作系统的并发性是通过分时实现的。

操作系统实现并行需有相关硬件的加持，例如多流水线或多处理器硬件环境。

## Q4：请解释操作系统【共享】的概念？

所谓共享是指系统中的资源可供内存中多个并发执行的进程（线程）共同使用。

相应地，把这种资源共同使用称为资源共享，或资源复用。

根据资源属性不同，对资源复用方式也不同，目前主要分【互斥共享方式】和【同时访问方式】

【互斥共享方式】：系统中的某些资源：如打印机、磁带机等，虽然可以提供给多个进程（线程）使用，但是应规定在一段时间内，只允许一个进程访问该资源。一段时间内仅允许一个进程访问的资源称为【临界资源】

【同时访问方式】：系统中还有另外一些资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里的同时指的是并发。

## Q5：请解释操作系统【虚拟】的概念？

【虚拟】是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的。

虚拟技术分为【时分复用技术】和【空分复用技术】

【时分复用技术】：虚拟处理器，即微观上处理机在各个微小的时间段内交替着为各个进程服务。

【空分复用技术】：如虚拟存储器技术。

## Q6：请解释操作系统【异步】的概念？

在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。

并不是进入内存的进程将会同步进行，实际上，在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。

由于资源等因素的限制，进程的执行通常不是一气呵成，而是以走走停停的方式运行。

进程是以人们不可预知的速度向前推进的，此即进程的【异步】性。

# 2. 运行机制和体系结构

## Q1：什么是指令？代码和指令的区别？

【代码】：我们能理解，但是计算机CPU无法理解。但可以通过某些程序转换为指令

【指令】：我们不能理解，但计算机CPU能理解并执行指令之中相应的操作

## Q2：非特权指令和特权指令？

【非特权指令】：安全的指令，程序可以随便调用

【特权指令】：危险的指令，只允许某些程序调用

## Q3：CPU有哪两种状态？

【用户态】：当CPU处于用户态时，CPU只能执行非特权指令

【核心态】：当CPU处理核心态时，CPU能执行非特权指令和特权指令

## Q4：CPU如何知道自己处于什么状态？

CPU通过【程序状态寄存器PSW】判断，该寄存器值是0时，表示CPU处于用户态；而为1时，表示CPU处于核心态。

## Q5：应用程序和内核程序？

在用户态和核心态的基础上，将程序划分为应用程序和内核程序。

【应用程序】：应用程序运行于用户态，只能执行非特权指令

【内核程序】：内核程序是操作系统的管理者，运行于核心态，可以执行特权指令和非特权指令

## Q6：大内核和微内核

操作系统的内核非为大内核和微内核

![image-20210504174130127](.\images\image-20210504174130127.png)

【大内核】相对于【微内核】承担了更多的工作，后者相应的工作需要CPU切换到【用户态】才可执行，降低了效率，但是分工更明确。

## Q7：用户空间和内核空间？与用户态内核态的区别？用户栈和内核栈？

用户进程所在的内存区域称为用户空间

处于用户态的进程只能访问用户空间，处于内核态的程序可以访问用户空间和内核空间。

每个进程有用户栈和内核栈，分别用于存储用户空间地址和内核空间地址。

![image-20210522203020700](.\images\image-20210522203020700.png)

# 3. 中断和异常

## Q1：什么是中断，中断的作用？

操作系统程序分为【应用程序】和【内核程序】，前者运行于【用户态】，只能执行【非特权指令】；后者运行于【核心态】可以执行【特权指令】和【非特权指令】。

【内核程序】是操作系统的管理者，执行【内核程序】时，操作系统内核获得CPU的使用权。

【中断】会使CPU由【用户态】变为【核心态】，使操作系统重新夺回CPU的使用权。

【中断】是让操作系统内核夺回CPU使用权的唯一途径

## Q2：CPU在【用户态】和【核心态】之间是如何相互切换的？

【用户态】->【核心态】：由【中断】引发，触发中断信号意味着操作系统将强行夺回CPU的使用权

【核心态】->【用户态】：通过下发特权指令，将PSW的标志位切换至【用户态】，这个操作意味着【操作系统】主动让出CPU的使用权

## Q3：中断的分类？

中断可以分为【内中断】和【外中断】

【内中断】与当前执行的【指令】有关，中断信号来自CPU内部

【外中断】与当前执行的【指令】无关，中断信号来自CPU外部

## Q4：中断机制的基本原理？什么是中断处理程序？

不同的中断信号，需要不同的【中断处理程序】来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询【中断向量表】，以此来找到相应的中断处理程序在内存中的位置。

# 4. 系统调用

## Q1：什么是系统调用？有何作用？

![image-20210504232425049](.\images\image-20210504232425049.png)

操作系统作为用户与计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。

【系统调用】是操作系统提供给应用程序（编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。

对系统中的各种共享资源都由操作系统统一保管，因此在【应用程序】中，凡是与资源相关的操作（如存储分配，I/O操作，文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。

## Q2：系统调用和库函数的区别？

【库函数】对【系统调用】做了进一步的封装，让上层应用程序的调用更加方便。

另外，【库函数】隐藏了操作系统之间的区别，实现跨平台。

## Q3：系统调用后面的过程

系统调用必须执行在【核心态】，一般通过【陷入指令】将CPU从【用户态】切换至【核心态】

1. 传递系统调用参数
2. 执行陷入指令（用户态）
3. 执行系统调用相应的服务程序（核心态）
4. 返回用户程序

所以【陷入指令】也是唯一一个只能运行在用户态的指令。

# 5. 进程

## Q1：什么是进程？

【进程】是进程实体的运行过程，是系统进行资源分配的一个独立单位。

## Q2：进程的组成？

【进程】由【PCB】、【程序段】、【数据段】组成

PCB（Processing Control Block）是操作系统用于管理进程的模块，包含了进程的静态信息，例如【进程pid】、【进程优先级】等

程序段和数据段构成了进程执行时的动态信息，【程序段】存放要执行的代码，【数据段】存放程序运行过程中处理的各种数据

## Q3：进程有哪几种状态？

进程有五种状态：

【创建态/New】：进程正在被创建，操作系统为进程分配资源，初始化PCB。

【就绪态/Ready】：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。（有资源，只差CPU）

【运行态/Running】：占用CPU，在CPU上执行。（单核处理机场景每一时刻仅有一个进程处于运行态）

【阻塞态/Waiting/Blocked】：因等待某一事件暂时不能运行

【终止态/Terminated】：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

## Q4：进程状态之间何时切换？

![image-20210516210209556](.\images\image-20210516210209556.png)

## Q5：进程状态如何实现切换，或者进程控制是如何实现的？

![image-20210516210753297](.\images\image-20210516210753297.png)

进程控制是通过上图实现的，简单来说，在每次状态切换时，进程控制需要注意

1. PCB中状态的修改
2. 进程运行环境的保存与恢复
3. 就绪队列/阻塞队列中进程PCB的管理（注：队列里放的是PCB）

## Q6：什么是原语，有什么作用？

原语（primitive）是操作系统中不可被中断的一次原子操作，可以保证操作系统的关键任务顺利执行，不被中断。

进程状态的切换不可被中断，可以用原语实现。

原语是通过【关中断指令】和【开中断指令】实现的，开中断指令执行后，才可相应外部中断信号。

![image-20210516213149518](.\images\image-20210516213149518.png)

## Q7：进程间通信有哪几种方式？

进程间通信（Inter-process Communication）的方式有：

1. 管道（Pipe）

2. 命名管道（Named Pipe）
3. 消息队列（message queue）
4. 信号量（semaphore）
5. 信号（signal）
6. 共享内存（shared memory）
7. 套接字（socket）

详细的说明放在linux的【进程管理】章节说明。

# 6. 线程

## Q1：什么是线程？

线程可以理解为“轻量级进程”，是CPU执行的最小单位（进程是操作系统资源分配的最小单位）。

通过引入线程，使得同一进程内部多线程间可以实现并发，提升了系统的并发度。

此外，同一进程不同线程间并发的开销，不需要切换进程环境，系统开销小。

## Q2：线程模型？线程的组成？

![image-20210530204148748](.\images\image-20210530204148748.png)

多个线程共享进程控制块（PCB）以及进程中的用户地址空间。

每个线程包含线程控制块（TCB: Thread Control Block）和独立的堆栈。

## Q3：线程的分类？

线程分为用户级线程（ULT: User Level Thread）和内核级线程（KLT: Kernel Level Thread）

用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）。

用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。

从用户看来，是有多个线程，但是在操作系统内核看来，并不能意识到线程的存在。

内核级线程的管理工作由操作系统内核完成。

操作系统内核执行在核心态的指令，只是对上层提供【系统调用API接口】，上层调用时，是感知不到核心态下真正执行时是以何种线程状态执行的。

综上，可以这么简单理解：

1. 用户级线程是用户视角能看到的线程
2. 内核级线程是操作系统内核视角能看到的线程

## Q4：线程的实现方式？或者用户级线程与内核级线程的组合方式？

包含三种：多对一，一对一和一对多

【多对一】

![image-20210530205530286](.\images\image-20210530205530286.png)

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，效率高

缺点：当一个用户级线程阻塞后，整个进程都会阻塞

【一对一】

![image-20210530211216464](.\images\image-20210530211216464.png)

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。在多核机器上，多线程可以并行执行。

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

【多对多】

![image-20210530211420980](.\images\image-20210530211420980.png)

兼具并发度高和适度占用内核级线程资源两个优点。

# 7. 处理机调度



